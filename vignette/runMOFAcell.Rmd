---
title: "Running MOFA for multicellular factor analysis"
author: "Ricardo Ramirez"
date: "2023-02-13"
output:
  md_document:
    variant: markdown_github
editor_options: 
  chunk_output_type: console
---

```{r setup, message=FALSE, warning=FALSE}
library(MOFA2)
library(HDF5Array)
library(ComplexHeatmap)
library(circlize)
library(tidyverse)
library(scater)
library(scran)
library(edgeR)
library(decoupleR)
reticulate::use_condaenv(condaenv = "/Users/ricardoramirez/opt/miniconda3/envs/MOFA")
```

## Multicellular factor analysis

We repurposed the statistical framework of multi-omics factor analysis [(MOFA)](https://www.embopress.org/doi/full/10.15252/msb.20178124) and [MOFA+](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-020-02015-1) to analyze cross-condition single cell atlases. These atlases profile molecular readouts (eg. gene expression) of individual cells per sample that can be classified into groups based on lineage (cell types) or functions (cell states). We assumed that this nested design could be represented as a multi-view dataset of a collection of patients, where each individual view contains the summarized information of all the features of a cell type per patient (eg. pseudobulk). In this data representation there can be as many views as cell types in the original atlas. MOFA then is used to estimate a latent space that captures the variability of patients across the distinct cell types. The estimated factors composing the latent space can be interpreted as a multicellular program that captures coordinated expression patterns of distinct cell types. The cell type specific gene expression patterns can be retrieved from the factor loadings, where each gene of each cell type would contain a weight that contributes to the factor score. Similarly, as in the application of MOFA to multiomics data, the factors can be used for an unsupervised analysis of samples or can be associated to biological or technical covariates of the original samples. Additionally, the reconstruction errors per view and factor can be used to prioritize cell types associated with covariates of interest.

## Data

Here we demonstrate how to use MOFA for a multicellular factor analysis by applying it to a cross-condition atlas. Single nuclei RNAseq (sn-RNAseq) gene count expression matrices from 27 human heart tissue samples (patient-area) from our previous [work](https://www.nature.com/articles/s41586-022-05060-x) were used. Samples were previously annotated as myogenic-enriched, ischemic-enriched, and fibrotic-enriched, summarizing the distinct physiological zones and time-points after human myocardial infarction. The data was downloaded from the [Human Cell Atlas](https://data.humancellatlas.org/explore/projects/e9f36305-d857-44a3-93f0-df4e6007dc97) and imported into a SummarizedExperiment v1.24.0 R object, before generating pseudobulk expression profiles for each cell type and patient. The pseudobulk expression of the data can be downloaded from [FigShare]().

```{r}
meta <- read_csv("./data_MI/pb_metadata.csv", show_col_types = FALSE)
print(meta, n = 30)
```

## 1. Processing pseudobulk expression profiles

We will assume that regardless of the preferred way of storing your pseudobulk data, a count matrix (genes in rows, samples in columns) will be accompanied by the annotations of the columns that contain the information of the cell type and sample of origin of the pseudobulk expression vector. 

In the case of this atlas, pseudobulk data was stored in `SummarizedExperiment`

```{r}
pbulk_obj <- readRDS("./data_MI/mi_pb.rds")

SummarizedExperiment::assay(pbulk_obj[1:5,1:5], "counts")
```

```{r}
SummarizedExperiment::colData(pbulk_obj)[1:5,]
```

However, we will guide you on the creation of an universal input for a multicellular factor analysis

#### Prepare a count matrix and a column annotation

Counts should be a matrix containing genes in rows and samples in columns

```{r}
counts <- assay(pbulk_obj, "counts")
dim(counts)
```

Column data must contain 3 columns: 
"donor_id" = sample id
"cell_type" = which will define each view in the MOFA model
"ncells" = number of cells from which the pseudobulk profile was made

Functions like `scuttle::summarizeAssayByGroup()` already provides this type of information

```{r, eval=T, echo=F}
coldata <- colData(pbulk_obj) %>%
  as.data.frame() %>%
  dplyr::rename("donor_id" = "patient_region_id",
         "cell_counts" = "ncells") %>%
  dplyr::mutate(colid = paste0(cell_type, "_", donor_id)) %>%
  tibble::column_to_rownames("colid")

colnames(counts) <- rownames(coldata)
```

#### Prepare input for multicellular factor analysis - Function defintion

Here we propose a workflow that can be used to process, filter, normalize, and format data ready for a MOFA model for multicellular factor analysis

1. We rely on `SummarizedExperiment` to prepare data for processing

```{r}
# Creates summarized experiment from a count matrix and column annonations
# counts: a count matrix with genes in rows and samples as named columns
# coldata: a data frame with at least 3 columns: cell_type, donor_id, cell_counts

create_init_exp <- function(counts, coldata) {
  
  pb_dat <- SummarizedExperiment(assays = list("counts" = counts), colData = DataFrame(coldata))
  
  return(pb_dat)
}
```

2. For each cell type we keep profiles generated at least from **n** number of cells 

```{r}
# Filter pseudobulk expression profiles generated with less than n cells
# pb_dat = summarized experiment containing pseudobulk profiles generated from create_init_exp
# cts = must be a vector with cell_type names that you want to keep in your model
# ncells = minimum number of cells per profile

filt_profiles <- function(pb_dat, ncells = 50, cts) {
  
  # by n of cells 
  
  ix <- which(colData(pb_dat)[,"cell_counts"] >= ncells)
  pb_dat <- pb_dat[, ix]

  # by views of interest
  
  if(is.null(cts)) {
    
    cts <- set_names(colData(pb_dat)[,"cell_type"] %>%
                       unique()) 
    
  } else {
    
    cts <- purrr::set_names(cts)
    
  }
  
  pb_dat_list <- map(cts, function(ctype) { 
    
    ix <- which(colData(pb_dat)[,"cell_type"] == ctype)
    
    return(pb_dat[,ix])
    
  })
  
  return(pb_dat_list)
  
}
```

3. For each cell-type (view) we filter lowly expressed genes using `edgeR::filterByExpr()`

```{r}
# Performs filtering of lowly expressed genes
# pb_dat_list = list of summarized experiments generated from filt_profiles
# min.count = as in edgeR::filterByExpr, minimum count required for at least some samples
# min.prop = as in edgeR::filterByExpr, minimum proportion of samples in the smallest group that express the gene.

filt_gex_byexpr <- function(pb_dat_list, min.count, min.prop) {
  
  pb_dat_red <- map(pb_dat_list, function(x) {
    
    useful_genes <- edgeR::filterByExpr(x, min.count = min.count, min.prop = min.prop)
    
    return(x[useful_genes, ])
  })
  
  return(pb_dat_red)
  
}
```

4. Normalization of pseudobulk expression profiles using Trimmed Mean of the M-values (TMM) from `edgeR::calcNormFactors`

```{r}
# Performs normalization via TMM
# pb_dat_list = list of summarized experiments generated from filt_profiles
# scale_factor = value from which the normalized value is multiplied before log1p transformation

tmm_trns <- function(pb_dat_list, scale_factor = 1000000) {

  pb_dat_red <- map(pb_dat_list, function(x) {
    all_nf <- edgeR::calcNormFactors(x, method = "TMM")
    sfs <- all_nf$samples$lib.size * all_nf$samples$norm.factors
    pb <- sweep(assay(x, "counts"), MARGIN = 2, sfs, FUN = "/")
    assay(x, "logcounts") <- log1p(pb * scale_factor)
    
    return(x)
    
  })
  
  return(pb_dat_red)
  
}
```

5. Identification of highly variable genes per cell type using `scran::getTopHVGs()`

```{r}
# Performs filtering of highly variable genes (after data transformation)
# pb_dat_list = list of summarized experiments generated from filt_profiles
# prior_hvg = default is NULL, which will indicate the function to find hvgs. Alternatively
# a named list (with cell types as names) can be provided to manually select the genes
# the user wants to keep. If the prior lacks some cell types, then hvgs are estimated for them.
# var.threshold = Identical as in scran::getTopHVGs, minimum threshold on the metric of variation.
# Only used if prior_hvg = NULL

filt_gex_byhvg <- function(pb_dat_list, prior_hvg = NULL, var.threshold = 1) {
  
  if(is.null(prior_hvg)) {
    
    pb_dat_red <- map(pb_dat_list, function(x) {
      hvg <- getTopHVGs(x,var.threshold = var.threshold)
      return(x[hvg, ])
    }) 
    
    return(pb_dat_red)
    
  } else {
    
    cts_in_data <- set_names(names(pb_dat_list))
    cts_in_prior <- set_names(names(prior_hvg))
    
    in_cts <- cts_in_data[cts_in_data %in% cts_in_prior]
    out_cts <- cts_in_data[!cts_in_data %in% cts_in_prior]
    
    in_cts_data <- pb_dat_list[in_cts]
    
    for(ct in in_cts) {
      ct_genes <- in_cts_data[[ct]] %>% rownames()
      ct_genes <- ct_genes[ct_genes %in% prior_hvg[[ct]]]
      in_cts_data[[ct]] <- in_cts_data[[ct]][ct_genes,]
    }
    
    if(length(out_cts) == 0) {
      
      return(in_cts_data)
      
    } else {
      
      out_cts_data <- pb_dat_list[out_cts]
      
      out_cts_data <- map(out_cts_data, function(x) {
        hvg <- getTopHVGs(x,var.threshold = var.threshold)
        return(x[hvg, ])
      }) 

      return(c(in_cts_data, out_cts_data))
      
    }
  }
}
```

6. You can also filter the highly variable genes of each cell type, by avoiding genes considered  background

```{r}
# Performs filtering of highly variable genes (after data transformation)
# This is based on marker genes
# The assumption is that background gene expression can be traced
# by expression of cell type marker genes in cell types which shouldn't
# express the gene.
# pb_dat_list = list of summarized experiments generated from filt_profiles
# In @prior_mrks one must provide a named list with marker genes defined by the user

# We will keep only marker genes in the hvgs if they are expressed in the expected cell type

filt_gex_bybckgrnd <- function(pb_dat_list, prior_mrks) {
  
  # Current genes per view
  ct_genes <- map(pb_dat_list, rownames) %>%
    enframe("view","gene") %>%
    unnest()
  
  prior_mrks_df <- prior_mrks %>%
    enframe("view_origin","gene") %>%
    unnest() %>%
    dplyr::mutate(marker_gene = TRUE)
  
  # Here are genes that aren't cell type markers
  ok_genes <- ct_genes %>%
    left_join(prior_mrks_df, by = "gene") %>%
    dplyr::filter(is.na(marker_gene)) %>%
    dplyr::select(view, gene)
  
  # Here are genes selected as HVG that are marker
  # genes, we will keep only genes if they appear
  # in the right cell
  not_bckground_genes <- ct_genes %>%
    left_join(prior_mrks_df, by = "gene") %>%
    na.omit() %>%
    unnest() %>%
    dplyr::filter(view == view_origin) %>%
    dplyr::select(view, gene)
  
  clean_hvgs <- bind_rows(ok_genes, 
                          not_bckground_genes) %>%
    group_by(view) %>%
    nest() %>%
    dplyr::mutate(data = map(data, ~.x[[1]])) %>%
    deframe()
  
  pb_dat_list <- pb_dat_list %>%
    filt_gex_byhvg(pb_dat_list = .,
                   prior_hvg = clean_hvgs,
                   var.threshold = NULL)
  
  return(pb_dat_list)
}

```

7. Finally create a data frame ready to be used in MOFA

```{r}
# Makes a MOFA ready data set
# pb_dat_list = list of summarized experiments generated from filt_profiles

pb_dat2MOFA <- function(pb_dat_list) {
  
  pb_red <- map(pb_dat_list, function(x) {
    
    dat <- assay(x, "logcounts") 
    
    colnames(dat) <- colData(x)[,"donor_id"]
    
    dat %>%
      as.data.frame() %>%
      tibble::rownames_to_column("feature") %>%
      pivot_longer(-feature, names_to = "sample", values_to = "value")
    
  }) %>% 
    enframe(name = "view") %>%
    unnest() %>%
    dplyr::mutate(feature = paste0(view, "_", feature))
  
  return(pb_red)
  
}
```

#### Prepare input for multicellular factor analysis - Application

Here we show how all of these functions can be used to prepare your own data for a multicellular factor analysis

1. Define the cell types (views) to include in the model

```{r}
cts <- c("CM", "Endo", "Fib", "Lymphoid",
         "Myeloid", "PC", "vSMCs") 
```

2. Collect marker genes per cell type which are going to be used to filter background from the model

```{r}
# Marker genes from Kuppe et al
mrkr_genes <- read_csv("./data_MI/edgeR_cellmrkrs.csv", show_col_types = FALSE)
mrkr_genes <- mrkr_genes %>% #dplyr::filter(!name %in% exclude_ct) %>%
  dplyr::filter(FDR < 0.01, logFC > 1) %>%
  dplyr::select(name, gene) %>%
  dplyr::rename("lineage" = name) %>%
  group_by(lineage) %>%
  nest() %>%
  dplyr::mutate(data = map(data, ~.x[[1]])) %>%
  deframe()
```

3. Transform a pseudobulk expression matrix into a multi-view representation. Filter out profiles with low number of cells, filter lowly expressed genes per view, normalize data, identify highly variable genes, filter background and make the object MOFA ready

```{r, warning=FALSE, message=FALSE}
pb_dat <- create_init_exp(counts = counts,
                          coldata = coldata) %>%
  filt_profiles(pb_dat = ., # Optional
                ncells = 25,
                cts = cts) %>%
  filt_gex_byexpr(pb_dat_list = .,
                  min.count = 100,
                  min.prop = 0.25) %>%
  tmm_trns(pb_dat_list = .) %>%
  filt_gex_byhvg(pb_dat_list = ., # Optional
                 prior_hvg = NULL,
                 var.threshold = 0) %>%
  filt_gex_bybckgrnd(pb_dat_list = ., # Optional
                     prior_mrks = mrkr_genes) %>%
  pb_dat2MOFA(pb_dat_list = .)

```

## 2. Running MOFA

Once the single cell data is transformed into a multi-view representation, now we can use MOFA to run a multicellular factor analysis.

We will try to identify 6 factors that explain the variability between patients captured by the seven different cell-types. 

MOFA self-regularizes and will indicate a potential optimal number of factors useful to describe the variability of your data, we advise to follow the indications of [MOFA](https://biofam.github.io/MOFA2/tutorials.html)

Every factor captures coordination of gene expression across cell types and will be called multicellular gene factors for the rest of the vignette.

It is important to clarify what these factors capture:

a) Coordinated expression of identical genes (generalistic response) across cell-types
b) Coordinated expression of different genes (cell-type specific response) across cell-types

Fitting the model should take seconds.

```{r, message=FALSE, results='hide', warning=FALSE}
MOFAobject <- MOFA2::create_mofa(pb_dat)

data_opts <- MOFA2::get_default_data_options(MOFAobject)
train_opts <- get_default_training_options(MOFAobject)
model_opts <- MOFA2::get_default_model_options(MOFAobject)

# This avoids the regularization of multicellular programs per cell type.
# This avoids less sparse gene weights
model_opts$spikeslab_weights <- FALSE 

model_opts$num_factors <- 6

#Prepare MOFA model:
MOFAobject <- prepare_mofa(object = MOFAobject,
                           data_options = data_opts,
                           model_options = model_opts,
                           training_options = train_opts)
  
outfile <- file.path("./results/vignettemodel.hdf5")

model <- MOFA2::run_mofa(MOFAobject, outfile)
```

## 3. Interpreting the model

The multicellular factor analysis fitted with MOFA can be interpreted at different levels

#### Factor scores for an unsupervised analysis of the data

The initial motivation of this analysis is to perform an unsupervised analysis of single cell data samples that captures its variability across cell types. 

We used the latent space inferred by MOFA to achieve this, here an example of the first 3 samples

```{r}
factor_scores <- MOFA2::get_factors(model, factors = "all")[[1]]
factor_scores[1:3,]
```

To visualize the variability of samples one can use `ComplexHeatmap`:

```{r, fig.height=5, fig.width=4}
# Aesthetic
ht_opt$ROW_ANNO_PADDING <- unit(2.5, "mm")
ht_opt$COLUMN_ANNO_PADDING <- unit(2.5, "mm")

# Association colors
col_fun_fact <- circlize::colorRamp2(seq(-5, 5, length = 50), hcl.colors(50,"Green-Brown",rev = T))

# This creates the annotations of samples
row_anns <- meta %>%
  as.data.frame() %>%
  dplyr::select(sample, patient_group, batch) %>%
  column_to_rownames("sample")

row_ha <- rowAnnotation(condition = row_anns$patient_group,
                       batch = row_anns$batch,
                       col = list(condition = c("fibrotic" = "#4169E1",
                                                    "myogenic" = "#FF6666", 
                                                    "ischemic" = "#3CB371"),
                                  batch = c("A" = "black",
                                            "B" = "darkgrey")),
                       gap = unit(2.5, "mm"),
                       border = TRUE)

scores_hmap <- Heatmap(factor_scores[rownames(row_anns),],
                       name = "factor_scores",
                       right_annotation = row_ha,
                       cluster_columns = FALSE,
                       show_row_dend = TRUE,
                       show_row_names = FALSE,
                       border = TRUE,
                       gap = unit(2.5, "mm"),
                       col = col_fun_fact)

draw(scores_hmap)

```

This latent space can be used for other type of dimensionality reductions like multidimensional scaling or uniform manifold approximation and projection.

This latent space however only captures certain percentage of the variability across cell types, which can be consulted from the model results too

```{r, fig.height=4, fig.width=6}
model@cache$variance_explained$r2_total$single_group %>%
  enframe() %>%
  ggplot(aes(x = name, y = value)) +
  geom_bar(stat = "identity") +
  theme(axis.text.x =  element_text(angle = 90, size = 12, hjust = 1, vjust =0.5),
        axis.text = element_text(size = 12)) +
  ylab("R2") +
  xlab("")
```

#### Association of latent variables to covariates of interest

The latent space can also be used to associate sample covariates to multicellular programs.

Here we provide some helper functions to achieve this:

```{r}
#  Get scores of all factors from a model
#' model = MOFAcell model
#' meta = a data frame with sample + any other colums
#' factor = Factor# label
#' 
#' returns a df with the factor scores
get_allfscores <-  function(model, meta, factor, group = FALSE) {
  
  if(group) {
    
    factor_scores <- get_factors(model, factors = "all") %>%
      do.call(rbind, .)
      as.data.frame() %>%
      rownames_to_column("sample") %>%
      left_join(meta, by = "sample")  %>%
      pivot_longer(-colnames(meta), names_to = "Factor")
    
  } else { 
    
    factor_scores <- get_factors(model, factors = "all")[[1]] %>%
      as.data.frame() %>%
      rownames_to_column("sample") %>%
      left_join(meta, by = "sample")  %>%
      pivot_longer(-colnames(meta), names_to = "Factor")
    
    }
  
  return(factor_scores)
  
}

#  Get scores of factor of interest
#' model = MOFAcell model
#' meta = a data frame with sample + any other colums
#' factor = Factor# label
#' 
#' returns a df with the factor scores
get_fscores <- function(model, meta, factor, group = FALSE) {
  
  if(group) {
    
    factor_scores <- (get_factors(model, factors = "all") %>%
      do.call(rbind, .))[,factor, drop= F] %>%
      as.data.frame() %>%
      rownames_to_column("sample") %>%
      left_join(meta, by = "sample")
    
  } else { 
    
    factor_scores <- get_factors(model, factors = "all")[[1]][,factor, drop= F] %>%
      as.data.frame() %>%
      rownames_to_column("sample") %>%
      left_join(meta, by = "sample")
    
  }
  
  return(factor_scores)
  
}

# Perform ANOVAs to associate the latent space to features of interest
#' model = MOFAcell model
#' meta = a data frame with sample + any other colums
#' predicted_label = covariate used in association
#' 
get_associated_factors <- function(meta, model, predicted_label) {
  
  factors <- get_allfscores(model = model, meta = meta)
  
  # Get factors associated with patient group
  factors <- factors %>%
  dplyr::select_at(c("sample", predicted_label, "Factor", "value")) %>%
  group_by(Factor) %>%
  nest() %>%
  mutate(pvalue = map(data, function(dat) {
    
    gene_aov <- aov(as.formula(paste0("value ~ ", predicted_label)), data = dat) %>%
      broom::tidy() %>%
      dplyr::filter(term == predicted_label) %>%
      dplyr::select(term, p.value)
    
    return(gene_aov)
  })) %>%
  tidyr::unnest(pvalue) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(adj_pvalue = p.adjust(p.value))

  expl_var <- factors %>%
  dplyr::select(Factor, term, p.value, adj_pvalue)

  return(expl_var)
  
}
```

As an application, here we used ANOVA's to associate sample's factor scores to the distinct sample conditions or technical effects

```{r}
get_associated_factors(meta = meta,
                       model = model,
                       predicted_label = "patient_group")
```

Factor 1 is associated with patient conditions, we can visualize it

```{r, fig.height=4, fig.width=3}
get_allfscores(model = model, meta = meta) %>%
  dplyr::filter(Factor %in% c("Factor1")) %>%
  pivot_wider(names_from = Factor, values_from = value) %>%
  ggplot(., aes(x = patient_group,
                y = Factor1)) +
  geom_boxplot() +
  geom_point(size = 2) +
  theme_classic() +
  xlab("") +
  theme(axis.text.x = element_text(size =12, angle = 90, hjust = 1, vjust = 0.5),
        axis.text.y = element_text(size =12),
        legend.position = "none")
```

Similarly as before, we can explore the amount of explained variance of the original data captured by this factor alone

```{r}
model@cache$variance_explained$r2_per_factor[[1]]["Factor1",] %>%
  enframe() %>%
  ggplot(aes(x = name, y = value)) +
  geom_bar(stat = "identity") +
  theme(axis.text.x =  element_text(angle = 90, size = 12, hjust = 1, vjust =0.5),
        axis.text = element_text(size = 12)) +
  ylab("R2") +
  xlab("")
```

#### Multicellular programs

As previously mentioned, MOFAâ€™s factors can be interpreted as higher-order representations of multicellular programs, i.e. coordinated gene expression changes across cell types. These patterns encoded in the gene weights of a factor could include gene expression changes shared across multiple cell types and cell type specific expression changes.

```{r}
#' model = MOFAcell model
#' factor = Factor# label
#' returns a df with the factor loadings

get_floadings <- function(model, factor) {
  
  factor_loadings <- get_weights(model, as.data.frame = T) %>%
    as.data.frame() %>%
    dplyr::mutate(feature = strsplit(as.character(feature), "_") %>%
                    map_chr(., ~ .x[[2]]),
                  ctype = strsplit(as.character(view), "_") %>%
                    map_chr(., ~ .x[[1]])) %>%
    dplyr::rename("factors" = factor) %>%
    dplyr::select(-view) %>%
    dplyr::filter(factors == factor) %>%
    dplyr::select(-factors)
  
  return(factor_loadings)
  
}
```

```{r}
factor_loadings <- get_floadings(model = model,
              factor = "Factor1") %>%
  pivot_wider(names_from = ctype, 
              values_from = value, 
              values_fill = 0) %>%
  column_to_rownames("feature") %>%
  as.matrix()

head(factor_loadings)
```

Functional interpretation of them for example with pathway activities can help you to understand the multicellular processes describing the variability of samples.

Here we show an example using pathway activities from [PROGENy](https://www.nature.com/articles/s41467-017-02391-6) via `decoupleR`

```{r}
net <- decoupleR::get_progeny(organism = 'human', top = 1000)

ct_acts <- decoupleR::run_wmean(mat=factor_loadings, net=net, .source='source', .target='target',
                  .mor='weight', times = 100, minsize = 5)

ct_acts_mat <- ct_acts %>%
  dplyr::filter(statistic == "norm_wmean") %>%
  dplyr::mutate(score = ifelse(score <= -5, -5, score)) %>%
  dplyr::select(source, condition, score) %>%
  pivot_wider(values_from = score, names_from = condition) %>%
  column_to_rownames("source") %>%
  as.matrix()

head(ct_acts_mat)
```

```{r, fig.height=5, fig.width=3.5}
hmap <- ComplexHeatmap::Heatmap((ct_acts_mat), 
                        name = "progeny", 
                        show_row_dend = FALSE,
                        show_column_dend = FALSE)

draw(hmap)
```

Since the cell type specific expression of genes with positive gene weights associates with ischemic samples (see previous section), pathways with positive scores are also more related to ischemic samples. This confirms the expected inflammatory, fibrotic and hypoxic responses after myocardial infarction. 

```{r}
sessionInfo()
```

